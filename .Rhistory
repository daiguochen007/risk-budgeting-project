rb_weight2<- function(cov,rho,w_lb,w_ub,w0){
eval_f <- function(x) {
return(sum((x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b)^2) + rho*t(x)%*%cov%*%x)
}
# Gradient
eval_grad_f <- function(x) {
e<- diag(length(x))
res<-0
temp<- x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b
for (i in 1:length(x)){
res<- res+2*temp[i]*(e[i,]%*%t(cov[i,])+t(e[i,]%*%t(cov[i,])))%*%x
}
return(res + rho*2*cov%*%x)
}
# equality constraint function
eval_g0 <- function(x) {
return(sum(x)-1)
}
# jacobian of equality constraint
eval_jac_g0 <- function(x) {
return(rep(1,length(x)))
}
# solve fortfolio function
res <- nloptr( x0=w0,
eval_f=eval_f,
eval_grad_f=eval_grad_f,
eval_g_eq=eval_g0,
eval_jac_g_eq=eval_jac_g0,
lb = w_lb,
ub = w_ub,
opts=list("algorithm"="NLOPT_LD_SLSQP","xtol_rel"=1.0e-8))
#solution
return(res$solution)
}
rho<-100
beta<-0.6
while (rho >= 10^-6){
rho<- rho*beta
w0<- rb_weight2(cov,rho,w_lb,w_ub,w0)
print(w0)
}
library('nloptr')
while (rho >= 10^-6){
rho<- rho*beta
w0<- rb_weight2(cov,rho,w_lb,w_ub,w0)
print(w0)
}
cov<- matrix(c( 1.0,-0.9, 0.6,
-0.9, 1.0,-0.2,
0.6,-0.2, 4.0),nrow=3)
# initial values
w0<- rep(1/nrow(cov),nrow(cov))
b<- c(0.2,0.3,0.5)
w_lb = rep(-3,nrow(cov))
w_ub = rep(3,nrow(cov))
rb_weight<- function(cov,w0,b){
eval_f <- function(x) {
return(sum((x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b)^2)) #+ rho*t(x)%*%cov%*%x)
}
# Gradient
eval_grad_f <- function(x) {
e<- diag(length(x))
res<-0
temp<- x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b
for (i in 1:length(x)){
res<- res+2*temp[i]*(e[i,]%*%t(cov[i,])+t(e[i,]%*%t(cov[i,])))%*%x
}
return(res) # + rho*2*cov%*%x)
}
# equality constraint function
eval_g0 <- function(x) {
return(sum(x)-1)
}
# jacobian of equality constraint
eval_jac_g0 <- function(x) {
return(rep(1,length(x)))
}
# solve fortfolio function
res <- nloptr( x0=w0,
eval_f=eval_f,
eval_grad_f=eval_grad_f,
eval_g_eq=eval_g0,
eval_jac_g_eq=eval_jac_g0,
lb = w_lb,
ub = w_ub,
opts=list("algorithm"="NLOPT_LD_SLSQP","xtol_rel"=1.0e-8))
#solution
return(res$solution)
}
w0<- rb_weight(cov,w0,b)
w0*(cov%*%w0)/as.numeric(t(w0)%*%cov%*%w0)
cov<- matrix(c( 1.0, 0.3, 0.2,
0.3, 1.5, 0.4,
0.2, 0.4, 4.0),nrow=3)
# initial values
w0<- rep(1/nrow(cov),nrow(cov))
b<- c(0.2,0.3,0.5)
w_lb = rep(-3,nrow(cov))
w_ub = rep(3,nrow(cov))
ret<- c(0.02, 0.05, 0.1)
eval_f <- function(x) {
return(sum((x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b)^2))
}
lambda<-
eval_f(w0)
lambda<- 100
ret%*%w0
lambda<- 10
rb_optimization<- function(cov,w0,b,ret,lambda){
eval_f <- function(x) {
return(-1*ret%*%x + lambda * sum((x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b)^2))
}
# Gradient
eval_grad_f <- function(x) {
e<- diag(length(x))
res<-0
temp<- x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b
for (i in 1:length(x)){
res<- res+2*temp[i]*(e[i,]%*%t(cov[i,])+t(e[i,]%*%t(cov[i,])))%*%x
}
return(-1*ret+res)
}
# equality constraint function
eval_g0 <- function(x) {
return(sum(x)-1)
}
# jacobian of equality constraint
eval_jac_g0 <- function(x) {
return(rep(1,length(x)))
}
# solve fortfolio function
res <- nloptr( x0=w0,
eval_f=eval_f,
eval_grad_f=eval_grad_f,
eval_g_eq=eval_g0,
eval_jac_g_eq=eval_jac_g0,
lb = w_lb,
ub = w_ub,
opts=list("algorithm"="NLOPT_LD_SLSQP","xtol_rel"=1.0e-8))
#solution
return(res$solution)
}
w0<- rb_weight(cov,w0,b,ret,lambda)
w0<- rb_optimization(cov,w0,b,ret,lambda)
w0*(cov%*%w0)/as.numeric(t(w0)%*%cov%*%w0)
w0%*%ret
cov<- matrix(c( 1.0, 0.3, 0.2,
0.3, 1.5, 0.4,
0.2, 0.4, 4.0),nrow=3)
# initial values
w0<- rep(1/nrow(cov),nrow(cov))
b<- c(0.2,0.3,0.5)
w_lb<- rep(-3,nrow(cov))
w_ub<- rep(3,nrow(cov))
#expected return
ret<- c(0.02, 0.05, 0.1)
rf<- 0.01
sqrt(2)
rb_weight3<- function(cov,rho,w_lb,w_ub,w0,ret,rf){
eval_f <- function(x) {
sigma<- sqrt(t(x)%*%cov%*%x)
return(sum((x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b)^2) - rho * (ret%*%x-rf)/sigma )
}
# Gradient
eval_grad_f <- function(x) {
e<- diag(length(x))
res<-0
temp<- x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b
for (i in 1:length(x)){
res<- res+2*temp[i]*(e[i,]%*%t(cov[i,])+t(e[i,]%*%t(cov[i,])))%*%x
}
sigma<- sqrt(t(x)%*%cov%*%x)
return(res - rho*(ret/sigma - (ret%*%x-rf)/sigma^3 *cov%*%x ))
}
# equality constraint function
eval_g0 <- function(x) {
return(sum(x)-1)
}
# jacobian of equality constraint
eval_jac_g0 <- function(x) {
return(rep(1,length(x)))
}
# solve fortfolio function
res <- nloptr( x0=w0,
eval_f=eval_f,
eval_grad_f=eval_grad_f,
eval_g_eq=eval_g0,
eval_jac_g_eq=eval_jac_g0,
lb = w_lb,
ub = w_ub,
opts=list("algorithm"="NLOPT_LD_SLSQP","xtol_rel"=1.0e-8))
#solution
return(res$solution)
}
rho<-100
beta<-0.6
while (rho >= 10^-6){
rho<- rho*beta
w0<- rb_weight2(cov,rho,w_lb,w_ub,w0,ret)
print(w0)
}
while (rho >= 10^-6){
rho<- rho*beta
w0<- rb_weight3(cov,rho,w_lb,w_ub,w0,ret)
print(w0)
}
while (rho >= 10^-6){
rho<- rho*beta
w0<- rb_weight3(cov,rho,w_lb,w_ub,w0,ret,rf)
print(w0)
}
x<- w0
sigma<- sqrt(t(x)%*%cov%*%x)
ret/sigma
(ret%*%x-rf)/sigma^3
cov%*%x
(ret%*%x-rf)/sigma^3 * cov%*%x
((ret%*%x-rf)/sigma^3) * cov%*%x
as.numeric((ret%*%x-rf)/sigma^3) * cov%*%x
rho*(ret/sigma - as.numeric((ret%*%x-rf)/sigma^3) * cov%*%x )
rb_weight3<- function(cov,rho,w_lb,w_ub,w0,ret,rf){
eval_f <- function(x) {
sigma<- sqrt(t(x)%*%cov%*%x)
return(sum((x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b)^2) - rho * (ret%*%x-rf)/sigma )
}
# Gradient
eval_grad_f <- function(x) {
e<- diag(length(x))
res<-0
temp<- x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b
for (i in 1:length(x)){
res<- res+2*temp[i]*(e[i,]%*%t(cov[i,])+t(e[i,]%*%t(cov[i,])))%*%x
}
sigma<- sqrt(t(x)%*%cov%*%x)
return(res - rho*(ret/sigma - as.numeric((ret%*%x-rf)/sigma^3) * cov%*%x ))
}
# equality constraint function
eval_g0 <- function(x) {
return(sum(x)-1)
}
# jacobian of equality constraint
eval_jac_g0 <- function(x) {
return(rep(1,length(x)))
}
# solve fortfolio function
res <- nloptr( x0=w0,
eval_f=eval_f,
eval_grad_f=eval_grad_f,
eval_g_eq=eval_g0,
eval_jac_g_eq=eval_jac_g0,
lb = w_lb,
ub = w_ub,
opts=list("algorithm"="NLOPT_LD_SLSQP","xtol_rel"=1.0e-8))
#solution
return(res$solution)
}
rho<-100
beta<-0.6
while (rho >= 10^-6){
rho<- rho*beta
w0<- rb_weight3(cov,rho,w_lb,w_ub,w0,ret,rf)
print(w0)
}
#risk contribution of each asset
w0*(cov%*%w0)/as.numeric(t(w0)%*%cov%*%w0)
#volatility
sqrt(t(w0)%*%(cov%*%w0))
(ret%*%x-rf)/sqrt(t(x)%*%cov%*%x)
rb_weight2<- function(cov,rho,w_lb,w_ub,w0){
eval_f <- function(x) {
return(sum((x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b)^2) + rho*t(x)%*%cov%*%x)
}
# Gradient
eval_grad_f <- function(x) {
e<- diag(length(x))
res<-0
temp<- x*(cov%*%x) - as.numeric(t(x)%*%cov%*%x)*b
for (i in 1:length(x)){
res<- res+2*temp[i]*(e[i,]%*%t(cov[i,])+t(e[i,]%*%t(cov[i,])))%*%x
}
return(res + rho*2*cov%*%x)
}
# equality constraint function
eval_g0 <- function(x) {
return(sum(x)-1)
}
# jacobian of equality constraint
eval_jac_g0 <- function(x) {
return(rep(1,length(x)))
}
# solve fortfolio function
res <- nloptr( x0=w0,
eval_f=eval_f,
eval_grad_f=eval_grad_f,
eval_g_eq=eval_g0,
eval_jac_g_eq=eval_jac_g0,
lb = w_lb,
ub = w_ub,
opts=list("algorithm"="NLOPT_LD_SLSQP","xtol_rel"=1.0e-8))
#solution
return(res$solution)
}
rho<-100
beta<-0.6
while (rho >= 10^-6){
rho<- rho*beta
w0<- rb_weight2(cov,rho,w_lb,w_ub,w0)
print(w0)
}
ret<- c(0.5, 0.05, 0.1)
w0<- rep(1/nrow(cov),nrow(cov))
rho<-100
beta<-0.6
while (rho >= 10^-6){
rho<- rho*beta
w0<- rb_weight3(cov,rho,w_lb,w_ub,w0,ret,rf)
print(w0)
}
w0*(cov%*%w0)/as.numeric(t(w0)%*%cov%*%w0)
sqrt(t(w0)%*%(cov%*%w0))
(ret%*%x-rf)/sqrt(t(x)%*%cov%*%x)
w0<- rep(1/nrow(cov),nrow(cov))
ret<- c(0.1, 0.2, 0.5)
rho<-100
beta<-0.6
while (rho >= 10^-6){
rho<- rho*beta
w0<- rb_weight3(cov,rho,w_lb,w_ub,w0,ret,rf)
print(w0)
}
w0*(cov%*%w0)/as.numeric(t(w0)%*%cov%*%w0)
sqrt(t(w0)%*%(cov%*%w0))
(ret%*%x-rf)/sqrt(t(x)%*%cov%*%x)
w0<- rep(1/nrow(cov),nrow(cov))
rho<-1000
beta<-0.6
while (rho >= 10^-6){
rho<- rho*beta
w0<- rb_weight3(cov,rho,w_lb,w_ub,w0,ret,rf)
print(w0)
}
cov<- matrix(c( 1.0, 0.3, 0.2,
0.3, 1.5, 0.4,
0.2, 0.4, 4.0),nrow=3)
# initial values
w0<- rep(1/nrow(cov),nrow(cov))
b<- c(0.2,0.3,0.5)
w_lb<- rep(-3,nrow(cov))
w_ub<- rep(3,nrow(cov))
#expected return
ret<- c(0.1, 0.2, 0.5)
rf<- 0.01
cov<- matrix(c( 1.0, 0.3, 0.2,
0.3, 1.5, 0.4,
0.2, 0.4, 4.0),nrow=3)
# initial values
w0<- rep(1/nrow(cov),nrow(cov))
# weight bounds
w_lb<- rep(-3,nrow(cov))
w_ub<- rep(3,nrow(cov))
# risk weight bounds
rw_lb<- rep(0,nrow(cov))
rw_ub<- rep(0.5,nrow(cov))
#expected return
ret<- c(0.1, 0.2, 0.5)
rf<- 0.01
diag(cov)
x<- c(1/3,1/3,1/3)
var<- t(x)%*%cov%*%x
(cov%*%x+diag(cov)*x)/var
cov%*%x+diag(cov)*x)
(cov%*%x+diag(cov)*x)
var<- as.numeric(t(x)%*%cov%*%x)
(cov%*%x+diag(cov)*x)/var
(cov%*%x+diag(cov)*x)/var-2*x*(cov%*%x)*(cov%*%x)/var^2
eval_g1 <- function(x) {
sigma<- sqrt(t(x)%*%cov%*%x)
return(rw_lb-x*(cov%*%x)/sigma)
}
# jacobian of inequality constraint
eval_jac_g1 <- function(x) {
var<- as.numeric(t(x)%*%cov%*%x)
return((cov%*%x+diag(cov)*x)/var-2*x*(cov%*%x)*(cov%*%x)/var^2)
}
res <- check.derivatives(
.x=c(1/3,1/3,1/3),
func=eval_g1,
func_grad=eval_jac_g1, check_derivatives_print= all , a=c(.3, .8,.3) )
res <- check.derivatives(
.x=c(1/3,1/3,1/3),
func=eval_g1,
func_grad=eval_jac_g1, check_derivatives_print= all)
sigma<- as.numeric(sqrt(t(x)%*%cov%*%x))
rw_lb-x*(cov%*%x)/sigma
res <- check.derivatives(
.x=c(1/3,1/3,1/3),
func=eval_g1,
func_grad=eval_jac_g1, check_derivatives_print= all)
rw_lb-x*(cov%*%x)/sigma
rb_c_weight<- function(cov,rho,w_lb,w_ub,rw_lb,rw_ub,w0,ret,rf){
eval_f <- function(x) {
sigma<- sqrt(t(x)%*%cov%*%x)
return(-1* rho * (ret%*%x-rf)/sigma )
}
# Gradient
eval_grad_f <- function(x) {
sigma<- sqrt(t(x)%*%cov%*%x)
return( -1 * rho*(ret/sigma - as.numeric((ret%*%x-rf)/sigma^3) * cov%*%x ))
}
# equality constraint function
eval_g0 <- function(x) {
return(sum(x)-1)
}
# jacobian of equality constraint
eval_jac_g0 <- function(x) {
return(rep(1,length(x)))
}
# inequality constraint function
eval_g1 <- function(x) {
sigma<- as.numeric(sqrt(t(x)%*%cov%*%x))
return(rw_lb-x*(cov%*%x)/sigma)
}
# jacobian of inequality constraint
eval_jac_g1 <- function(x) {
var<- as.numeric(t(x)%*%cov%*%x)
return((cov%*%x+diag(cov)*x)/var-2*x*(cov%*%x)*(cov%*%x)/var^2)
}
# solve fortfolio function
res <- nloptr( x0=w0,
eval_f=eval_f,
eval_grad_f=eval_grad_f,
eval_g_eq=eval_g0,
eval_jac_g_eq=eval_jac_g0,
eval_g_ineq = eval_g1,
eval_jac_g_ineq = eval_jac_g1,
lb = w_lb,
ub = w_ub,
opts=list("algorithm"="NLOPT_LD_MMA","xtol_rel"=1.0e-8))
#solution
return(res$solution)
}
w0<- rb_c_weight(cov,rho,w_lb,w_ub,rw_lb,rw_ub,w0,ret,rf)
rb_c_weight<- function(cov,rho,w_lb,w_ub,rw_lb,rw_ub,w0,ret,rf){
eval_f <- function(x) {
sigma<- sqrt(t(x)%*%cov%*%x)
return(-1* (ret%*%x-rf)/sigma )
}
# Gradient
eval_grad_f <- function(x) {
sigma<- sqrt(t(x)%*%cov%*%x)
return( -1* (ret/sigma - as.numeric((ret%*%x-rf)/sigma^3) * cov%*%x ))
}
# equality constraint function
eval_g0 <- function(x) {
return(sum(x)-1)
}
# jacobian of equality constraint
eval_jac_g0 <- function(x) {
return(rep(1,length(x)))
}
# inequality constraint function
eval_g1 <- function(x) {
sigma<- as.numeric(sqrt(t(x)%*%cov%*%x))
return(rw_lb-x*(cov%*%x)/sigma)
}
# jacobian of inequality constraint
eval_jac_g1 <- function(x) {
var<- as.numeric(t(x)%*%cov%*%x)
return((cov%*%x+diag(cov)*x)/var-2*x*(cov%*%x)*(cov%*%x)/var^2)
}
# solve fortfolio function
res <- nloptr( x0=w0,
eval_f=eval_f,
eval_grad_f=eval_grad_f,
eval_g_eq=eval_g0,
eval_jac_g_eq=eval_jac_g0,
eval_g_ineq = eval_g1,
eval_jac_g_ineq = eval_jac_g1,
lb = w_lb,
ub = w_ub,
opts=list("algorithm"="NLOPT_LD_MMA","xtol_rel"=1.0e-8))
#solution
return(res$solution)
}
w0<- rb_c_weight(cov,rho,w_lb,w_ub,rw_lb,rw_ub,w0,ret,rf)
